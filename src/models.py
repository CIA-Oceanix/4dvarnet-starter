import pandas as pd
from pathlib import Path
import pytorch_lightning as pl
import kornia.filters as kfilts
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import xarray as xr
from src.utils import get_last_time_wei, get_linear_time_wei
from src.BCDUNet import BCDUNet

class Lit4dVarNet(pl.LightningModule):
    def __init__(self, solver, rec_weight, opt_fn, test_metrics=None, pre_metric_fn=None, norm_stats=None, persist_rw=True):
        super().__init__()
        self.solver = solver
        self.register_buffer('rec_weight', torch.from_numpy(rec_weight), persistent=persist_rw)
        self.test_data = None
        self._norm_stats = norm_stats
        self.opt_fn = opt_fn
        self.metrics = test_metrics or {}
        self.pre_metric_fn = pre_metric_fn or (lambda x: x)

    @property
    def norm_stats(self):
        if self._norm_stats is not None:
            return self._norm_stats
        elif self.trainer.datamodule is not None:
            return self.trainer.datamodule.norm_stats()
        return (0., 1.)

    @staticmethod
    def weighted_mse(err, weight):
        err_w = err * weight[None, ...]
        non_zeros = (torch.ones_like(err) * weight[None, ...]) == 0.0
        err_num = err.isfinite() & ~non_zeros
        '''
        import matplotlib.pyplot as plt
        fig, axs = plt.subplots(1,2,figsize=(10,10))
        im = axs[0].pcolormesh(err_num[0,3,:,:].detach().cpu().numpy(),vmin=0, vmax=1)
        im = axs[1].pcolormesh(err_num[0,3,:,:].detach().cpu().numpy(),vmin=0, vmax=1)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(im, cax=cbar_ax)
        plt.show()
        '''
        if err_num.sum() == 0:
            return torch.scalar_tensor(1000.0, device=err_num.device).requires_grad_()
        loss = F.mse_loss(err_w[err_num], torch.zeros_like(err_w[err_num]))
        return loss

    def training_step(self, batch, batch_idx):
        return self.step(batch, "train")[0]

    def validation_step(self, batch, batch_idx):
        return self.step(batch, "val")[0]

    def forward(self, batch):
        return self.solver(batch)
    
    def step(self, batch, phase=""):
        if self.training and batch.tgt.isfinite().float().mean() < 0.9:
            return None, None

        loss, out = self.base_step(batch, phase)
        grad_loss = self.weighted_mse( kfilts.sobel(out) - kfilts.sobel(batch.tgt), self.rec_weight)
        prior_cost = self.solver.prior_cost(self.solver.init_state(batch, out))
        self.log( f"{phase}_gloss", grad_loss, prog_bar=True, on_step=False, on_epoch=True)

        training_loss = 50 * loss + 1000 * grad_loss + 1.0 * prior_cost
        return training_loss, out

    def base_step(self, batch, phase=""):
        out = self(batch=batch)
        loss = self.weighted_mse(out - batch.tgt, self.rec_weight)

        with torch.no_grad():
            self.log(f"{phase}_mse", 10000 * loss * self.norm_stats[1]**2, prog_bar=True, on_step=False, on_epoch=True)
            self.log(f"{phase}_loss", loss, prog_bar=True, on_step=False, on_epoch=True)

        return loss, out

    def configure_optimizers(self):
        return self.opt_fn(self)

    def test_step(self, batch, batch_idx):
        if batch_idx == 0:
            self.test_data = []
        out = self(batch=batch)
        m, s = self.norm_stats

        self.test_data.append(torch.stack(
            [
                batch.input.cpu() * s + m,
                batch.tgt.cpu() * s + m,
                out.squeeze(dim=-1).detach().cpu() * s + m,
            ],
            dim=1,
        )) 

        batch = None
        out = None

    @property
    def test_quantities(self):
        return ['inp', 'tgt', 'out']

    def on_test_epoch_end(self):

        if isinstance(self.trainer.test_dataloaders,list):
            rec_da = self.trainer.test_dataloaders[0].dataset.reconstruct(
                self.test_data, self.rec_weight.cpu().numpy()
            )
        else:
            rec_da = self.trainer.test_dataloaders.dataset.reconstruct(
                self.test_data, self.rec_weight.cpu().numpy()
            )

        self.test_data = rec_da.assign_coords(
            dict(v0=self.test_quantities)
        ).to_dataset(dim='v0')

        metric_data = self.test_data.pipe(self.pre_metric_fn)
        metrics = pd.Series({
            metric_n: metric_fn(metric_data) 
            for metric_n, metric_fn in self.metrics.items()
        })

        print(metrics.to_frame(name="Metrics").to_markdown())
        if self.logger:
            self.test_data.to_netcdf(Path(self.logger.log_dir) / 'test_data.nc')
            print(Path(self.trainer.log_dir) / 'test_data.nc')
            self.logger.log_metrics(metrics.to_dict())

class Lit4dVarNet_SST(Lit4dVarNet):

    def __init__(self, path_mask, optim_weight, domain_limits, modify_weights= False, persist_rw=True, *args, **kwargs):
         super().__init__(*args, **kwargs)

         self.domain_limits = domain_limits
         self.strict_loading = False
         self.mask_land = np.isfinite(xr.open_dataset(path_mask).sel(**(self.domain_limits or {})).analysed_sst[0])

         if modify_weights:
             rec_weight = get_last_time_wei(patch_dims= {'time': 7, 'lat': 110, 'lon': 220},
                                             crop={'time': 0, 'lat': 0, 'lon': 0},
                                             offset=1)
             optim_weight = get_linear_time_wei(patch_dims= { 'time': 7, 'lat': 110, 'lon': 220}, 
                                             crop={'time': 0, 'lat': 0, 'lon': 0},
                                             offset=1)
         #self.register_buffer('rec_weight', torch.from_numpy(rec_weight), persistent=persist_rw)
         self.register_buffer('optim_weight', torch.from_numpy(optim_weight), persistent=persist_rw)

    def step(self, batch, phase=""):

        if self.training and batch.tgt.isfinite().float().mean() < 0.05:
            return None, None

        loss, out = self.base_step(batch, phase)
        grad_loss = self.weighted_mse(kfilts.sobel(out) - kfilts.sobel(batch.tgt),
                                      self.optim_weight)
        prior_cost = self.solver.prior_cost(self.solver.init_state(batch, out))
        self.log( f"{phase}_gloss", grad_loss, prog_bar=True, on_step=False, on_epoch=True)

        print(50*loss, 10*prior_cost, 1000*grad_loss)
        training_loss = 50 * loss + 10 * prior_cost + 1000 * grad_loss 
        return training_loss, out

    def base_step(self, batch, phase=""):

        '''
        # base_step used in train/val only
        inp, tgt, lon, lat, mask = batch.input.detach().cpu().numpy(), batch.tgt.detach().cpu().numpy(), batch.lat.detach().cpu().numpy(), batch.lon.detach().cpu().numpy(), batch.mask.detach().cpu().numpy()
        import matplotlib.pyplot as plt
        fig, axs = plt.subplots(1,5,figsize=(30,10))
        min, max = np.nanmin(inp[0,3,:,:]), np.nanmax(inp[0,3,:,:])
        im = axs[0].pcolormesh(inp[0,3,:,:],vmin=min, vmax=max)
        im = axs[1].pcolormesh(tgt[0,3,:,:],vmin=min, vmax=max)
        print(lon.shape)
        im = axs[2].pcolormesh(lon[0,0,:,:])
        im = axs[3].pcolormesh(lat[0,0,:,:])
        im = axs[4].pcolormesh(mask[0,0,:,:])
        fig.subplots_adjust(right=0.8)
        cbar_ax = fig.add_axes([0.85, 0.15, 0.05, 0.7])
        fig.colorbar(im, cax=cbar_ax)
        plt.show()
        '''

        out = self(batch=batch)
        loss = self.weighted_mse(out - batch.tgt, self.optim_weight)

        with torch.no_grad():
            self.log(f"{phase}_mse", 10000 * loss * self.norm_stats[1]**2, prog_bar=True, on_step=False, on_epoch=True)
            self.log(f"{phase}_loss", loss, prog_bar=True, on_step=False, on_epoch=True)

        return loss, out

    def on_test_epoch_end(self):

        if self.rec_weight.shape[1]!=(self.test_data[0][0][0].shape)[1]:
            nlat = (self.test_data[0][0][0].shape)[1]
            nlon = (self.test_data[0][0][0].shape)[2]
            rec_weight = get_last_time_wei(patch_dims= {'time': 7, 'lat': nlat, 'lon': nlon},
                                             crop={'time': 0, 'lat': 0, 'lon': 0},
                                             offset=1)
            self.rec_weight = torch.from_numpy(rec_weight).to(self.test_data[0].device)

        if isinstance(self.trainer.test_dataloaders,list):
            rec_da = self.trainer.test_dataloaders[0].dataset.reconstruct(
                self.test_data, self.rec_weight.cpu().numpy()
            )
        else:
            rec_da = self.trainer.test_dataloaders.dataset.reconstruct(
                self.test_data, self.rec_weight.cpu().numpy()
            )

        self.test_data = rec_da.assign_coords(
            dict(v0=self.test_quantities)
        ).to_dataset(dim='v0')

        # crop (if necessary) 
        self.test_data = self.test_data.sel(**(self.domain_limits or {}))
        self.mask_land = self.mask_land.sel(**(self.domain_limits or {})) 
        rzf_mask = True
        if rzf_mask:
            self.mask_land = self.mask_land.coarsen(lon=10,boundary='trim').mean(skipna=True).coarsen(lat=10,boundary='trim').mean(skipna=True)
            self.mask_land = (self.mask_land!=0.)

        #Â set NaN according to mask
        self.test_data = self.test_data.update({'inp':(('time','lat','lon'),self.test_data.inp.data),
                                                'tgt':(('time','lat','lon'),self.test_data.tgt.data),
                                                'analysed_sst':(('time','lat','lon'),self.test_data.out.data)})
        #self.test_data.coords['mask'] = (('lat', 'lon'), self.mask_land.values)
        #self.test_data = self.test_data.where(self.test_data.mask)

        metric_data = self.test_data.pipe(self.pre_metric_fn),
        metrics = pd.Series({
            metric_n: metric_fn(metric_data)
            for metric_n, metric_fn in self.metrics.items()
        })

        print(metrics.to_frame(name="Metrics").to_markdown())
        if self.logger:
            self.test_data.to_netcdf(Path(self.logger.log_dir) / 'test_data.nc')
            print(Path(self.trainer.log_dir) / 'test_data.nc')
            self.logger.log_metrics(metrics.to_dict())

class Lit4dVarNet_SST_wcoarse(Lit4dVarNet):

    def __init__(self, path_mask, optim_weight, domain_limits, persist_rw=True, *args, **kwargs):
         super().__init__(*args, **kwargs)

         self.domain_limits = domain_limits
         self.mask_land = np.isfinite(xr.open_dataset(path_mask).sel(**(self.domain_limits or {})).analysed_sst_LR[20])

         self.register_buffer('optim_weight', torch.from_numpy(optim_weight), persistent=persist_rw)

    def modify_batch(self,batch):
        batch = batch._replace(input=batch.input.nan_to_num())
        batch = batch._replace(tgt=batch.tgt.nan_to_num())
        return batch

    def step(self, batch, phase=""):

        if self.training and batch.tgt.isfinite().float().mean() < 0.05:
            return None, None

        batch = self.modify_batch(batch)
        loss, out = self.base_step(batch, phase)
        grad_loss = self.weighted_mse(kfilts.sobel(out) - kfilts.sobel(batch.tgt),
                                      self.optim_weight)
        prior_cost = self.solver.prior_cost(self.solver.init_state(batch, out))
        self.log( f"{phase}_gloss", grad_loss, prog_bar=True, on_step=False, on_epoch=True)

        print(50*loss, 10*prior_cost, 1000*grad_loss)
        training_loss = 50 * loss + 10 * prior_cost + 1000 * grad_loss
        return training_loss, out

    def base_step(self, batch, phase=""):

        out = self(batch=batch)
        loss = self.weighted_mse(out - batch.tgt, self.optim_weight)

        with torch.no_grad():
            self.log(f"{phase}_mse", 10000 * loss * self.norm_stats[1]**2, prog_bar=True, on_step=False, on_epoch=True)
            self.log(f"{phase}_loss", loss, prog_bar=True, on_step=False, on_epoch=True)

        return loss, out

    def test_step(self, batch, batch_idx):
        if batch_idx == 0:
            self.test_data = []

        batch = self.modify_batch(batch)
        out = self(batch=batch)
        m, s = self.norm_stats

        self.test_data.append(torch.stack(
            [
                ((batch.input*s+m) + batch.coarse).cpu(),
                ((batch.tgt*s+m) + batch.coarse).cpu(),
                ((out*s+m) + batch.coarse).squeeze(dim=-1).detach().cpu(),
            ],
            dim=1,
        ))

        batch = None
        out = None

    def on_test_epoch_end(self):

        if isinstance(self.trainer.test_dataloaders,list):
            rec_da = self.trainer.test_dataloaders[0].dataset.reconstruct(
                self.test_data, self.rec_weight.cpu().numpy()
            )
        else:
            rec_da = self.trainer.test_dataloaders.dataset.reconstruct(
                self.test_data, self.rec_weight.cpu().numpy()
            )

        self.test_data = rec_da.assign_coords(
            dict(v0=self.test_quantities)
        ).to_dataset(dim='v0')

        # crop (if necessary) 
        self.test_data = self.test_data.sel(**(self.domain_limits or {}))
        self.mask_land = self.mask_land.sel(**(self.domain_limits or {}))

        #Â set NaN according to mask
        self.test_data = self.test_data.update({'inp':(('time','lat','lon'),self.test_data.inp.data),
                                                'tgt':(('time','lat','lon'),self.test_data.tgt.data),
                                                'analysed_sst':(('time','lat','lon'),self.test_data.out.data)})
        self.test_data.coords['mask'] = (('lat', 'lon'), self.mask_land.values)
        self.test_data = self.test_data.where(self.test_data.mask)

        metric_data = self.test_data.pipe(self.pre_metric_fn),
        metrics = pd.Series({
            metric_n: metric_fn(metric_data)
            for metric_n, metric_fn in self.metrics.items()
        })

        print(metrics.to_frame(name="Metrics").to_markdown())
        if self.logger:
            self.test_data.to_netcdf(Path(self.logger.log_dir) / 'test_data.nc')
            print(Path(self.trainer.log_dir) / 'test_data.nc')
            self.logger.log_metrics(metrics.to_dict())

class Lit4dVarNet_OSE(Lit4dVarNet):

    def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)

    def step(self, batch, phase=""):
        print(100*batch.tgt.isfinite().float().mean())
        if self.training and 100*batch.tgt.isfinite().float().mean() < 0.1:
            return None, None

        loss, out = self.base_step(batch, phase)
        self.log( f"{phase}_loss", loss, prog_bar=True, on_step=False, on_epoch=True)

        training_loss = loss
        return training_loss, out

    @staticmethod
    def weighted_mse(err, weight):

        # remove nan from err and weight
        err_w = err * weight[None, ...]
        non_zeros = (torch.ones_like(err) * weight[None, ...]) == 0.0
        err_num = err.isfinite() & ~non_zeros
        if err_num.sum() == 0:
            return torch.scalar_tensor(1000.0, device=err_num.device).requires_grad_()
        loss = F.mse_loss(err_w[err_num], torch.zeros_like(err_w[err_num]))
        return loss


    def base_step(self, batch, phase=""):
 
        out = self(batch=batch)

        grad_out = kfilts.sobel(out,3)
        grad_tgt = kfilts.sobel(batch.tgt,3)
        lapl_out = kfilts.laplacian(out,3)
        lapl_tgt = kfilts.laplacian(batch.tgt,3)

        loss = self.weighted_mse(out - batch.tgt, self.rec_weight)
        #loss += self.weighted_mse(grad_out - grad_tgt, self.rec_weight)
        #loss += self.weighted_mse(lapl_out - lapl_tgt, self.rec_weight)

        with torch.no_grad():
            self.log(f"{phase}_mse", 10000 * loss * self.norm_stats[1]**2, prog_bar=True, on_step=False, on_epoch=True)
            self.log(f"{phase}_loss", loss, prog_bar=True, on_step=False, on_epoch=True)

        return loss, out

class GradSolver(nn.Module):
    def __init__(self, prior_cost, obs_cost, grad_mod, n_step, lr_grad=0.2, reset_state=True, **kwargs):
        super().__init__()
        self.prior_cost = prior_cost
        self.obs_cost = obs_cost
        self.grad_mod = grad_mod

        self.n_step = n_step
        self.lr_grad = lr_grad

        self._grad_norm = None
        self.reset_state = reset_state

    def init_state(self, batch, x_init=None):
        if x_init is not None:
            return x_init

        return batch.input.nan_to_num().detach().requires_grad_(True)

    def solver_step(self, state, batch, step):
        var_cost = self.prior_cost(state) + self.obs_cost(state, batch)
        grad = torch.autograd.grad(var_cost, state, create_graph=True)[0]

        gmod = self.grad_mod(grad)
        state_update = (
            1 / (step + 1) * gmod
                + self.lr_grad * (step + 1) / self.n_step * grad
        )

        return state - state_update

    def forward(self, batch):
        with torch.set_grad_enabled(True):
            state = self.init_state(batch)
            if self.reset_state:
                self.grad_mod.reset_state(batch.input)

            for step in range(self.n_step):
                state = self.solver_step(state, batch, step=step)
                if not self.training:
                    state = state.detach().requires_grad_(True)

            #if not self.training:
            #    state = self.prior_cost.forward_ae(state)
            #state = self.prior_cost.forward_ae(state)
        return state


class ConvLstmGradModel(nn.Module):
    def __init__(self, dim_in, dim_hidden, kernel_size=3, dropout=0.1, downsamp=None):
        super().__init__()
        self.dim_hidden = dim_hidden
        self.gates = torch.nn.Conv2d(
            dim_in + dim_hidden,
            4 * dim_hidden,
            kernel_size=kernel_size,
            padding=kernel_size // 2,
        )

        self.conv_out = torch.nn.Conv2d(
            dim_hidden, dim_in, kernel_size=kernel_size, padding=kernel_size // 2
        )

        self.dropout = torch.nn.Dropout(dropout)
        self._state = []
        self.down = nn.AvgPool2d(downsamp) if downsamp is not None else nn.Identity()
        self.up = (
            nn.UpsamplingBilinear2d(scale_factor=downsamp)
            if downsamp is not None
            else nn.Identity()
        )

    def reset_state(self, inp):
        size = [inp.shape[0], self.dim_hidden, *inp.shape[-2:]]
        self._grad_norm = None
        self._state = [
            self.down(torch.zeros(size, device=inp.device)),
            self.down(torch.zeros(size, device=inp.device)),
        ]

    def forward(self, x):
        if self._grad_norm is None:
            self._grad_norm = (x**2).mean().sqrt()
        x =  x / self._grad_norm
        hidden, cell = self._state
        x = self.dropout(x)
        x = self.down(x)
        gates = self.gates(torch.cat((x, hidden), 1))

        in_gate, remember_gate, out_gate, cell_gate = gates.chunk(4, 1)

        in_gate, remember_gate, out_gate = map(
            torch.sigmoid, [in_gate, remember_gate, out_gate]
        )
        cell_gate = torch.tanh(cell_gate)

        cell = (remember_gate * cell) + (in_gate * cell_gate)
        hidden = out_gate * torch.tanh(cell)

        self._state = hidden, cell
        out = self.conv_out(hidden)
        out = self.up(out)
        return out

class BaseObsCost(nn.Module):
    def __init__(self, w=1) -> None:
        super().__init__()
        self.w=w

    def forward(self, state, batch):
        msk = batch.input.isfinite()
        return self.w * F.mse_loss(state[msk], batch.input.nan_to_num()[msk])

class BilinAEPriorCost(nn.Module):
    def __init__(self, dim_in, dim_hidden, kernel_size=3, downsamp=None, bilin_quad=True, nt=None):
        super().__init__()
        self.nt = nt
        self.bilin_quad = bilin_quad
        self.conv_in = nn.Conv2d(
            dim_in, dim_hidden, kernel_size=kernel_size, padding=kernel_size // 2
        )
        self.conv_hidden = nn.Conv2d(
            dim_hidden, dim_hidden, kernel_size=kernel_size, padding=kernel_size // 2
        )

        self.bilin_1 = nn.Conv2d(
            dim_hidden, dim_hidden, kernel_size=kernel_size, padding=kernel_size // 2
        )
        self.bilin_21 = nn.Conv2d(
            dim_hidden, dim_hidden, kernel_size=kernel_size, padding=kernel_size // 2
        )
        self.bilin_22 = nn.Conv2d(
            dim_hidden, dim_hidden, kernel_size=kernel_size, padding=kernel_size // 2
        )

        self.conv_out = nn.Conv2d(
            2 * dim_hidden, dim_in, kernel_size=kernel_size, padding=kernel_size // 2
        )

        self.down = nn.AvgPool2d(downsamp) if downsamp is not None else nn.Identity()
        self.up = (
            nn.UpsamplingBilinear2d(scale_factor=downsamp)
            if downsamp is not None
            else nn.Identity()
        )

    def forward_ae(self, x):
        x = self.down(x)
        x = self.conv_in(x)
        x = self.conv_hidden(F.relu(x))

        nonlin = self.bilin_21(x)**2 if self.bilin_quad else (self.bilin_21(x) * self.bilin_22(x))
        x = self.conv_out(
            torch.cat([self.bilin_1(x), nonlin], dim=1)
        )
        x = self.up(x)
        return x

    def forward(self, state, exclude_params=False):
        if not exclude_params:
            return F.mse_loss(state, self.forward_ae(state))
        else:
            return F.mse_loss(state[:,:self.nt,:,:], self.forward_ae(state)[:,:self.nt,:,:])

